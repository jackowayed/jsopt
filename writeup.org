* Motivation
For our project, we created a tool for Javascript authors.  Since
modern web applications make heavy ues of Javascript for basic
functionality, modern web browsers contain very fancy Javascript
engines designed to maximize performance. Engines JIT Javascript code
to native code and also dynamically optimize the machine code.

However, due to the loose and freewheeling nature of Javascript, many
common Javascript programming paradigms create optimization barriers,
though often these barriers can be overcome. For instance, in Google's
V8 engine, Javascript objects are compiled to C++ classes to allow
very quick access to object fields. This is much faster than using a
hashtable to resolve field names to locations in memory.  Hoewver,
whenever a Javascript author adds a new field to an existing object,
V8 must create a new C++ class, as C++ classes cannot be changed like
a hashtable can be.

As another example, V8 attempts to inline function calls, but won't
inline if the target fuction's text is too large. However, when
calculating the size of the target function, V8 /includes comments/!
A frequently invoked Javascript function with a large comment
therefore may not be inlined while the same function without the
comment may be.

As a last example, V8 doesn't made no attempt to optimize statements
contained within try-catch blocks; such code is simply executed
slowly. However, if the try block contains some compute-heavy code
that can be easily moved to a separate function, refactoring the
compute-heavy code into a separate function allows V8 to optimize the
subsidiary function, essentially eliminating the try-catch penalty.

To this end, our tool seeks to help Javascript authors identify
optimizations barriers in their programs. Such barriers can usually be
easily rewritten to a semantically identical but optimizable form. 

* Tools
We built an optimization-barrier diagnostic tool around the Esprima
parsing library, a JS parser writen in JS. We also initially used an
Esprima derivative product called Esmorph, a JS mutation tool usable
as an instrumentation framework.

* Contribution
To implement our optimization-barrier diagnostic, we provide a
Javascript instrumentation framework. We took the existing Esmorph
Javascript instrumentation tool and extended its API to provide more
general functionality. Esmorph originally could only instrument by
inserting code at function entrances and exits; we extended the API to
be able to insert instrumenting code before variable declarations,
instrumentable lines, and instrumentable blocks.

* Specifics
** Try / catch
As of October 2012, V8 didn't even try -- ha -- to optimize try/catch
statements. However, as mentioned before, compute-heavy code
refactored into a separate function called from within the try/catch
can still be optimized. If V8 reports a blocked inline due to a
try/catch, we walk the AST emitted by Esprima looking for calls to the
function that couldn't be inlined and test if they're contained within
an offending try/catch statement.
** Adding fields to objects
Using the line instrumentation facility that we added to Esmorph, we
created a small tool that examines all expressions, assignments, and
=[]= field selections to determine when Javascript programs add new
fields to extant objects dynamically. This practice incurs a
performance penalty as engines like V8 must create a new C++ class to
represent the object with a new field. Moving these dynamic field
additions outside of performance sensitive inner loops and functions
thus present an easy way to extract more performance with little
source modification.
** Deoptimization?
** Returns?

